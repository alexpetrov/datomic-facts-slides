#+STARTUP: showall

#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:nil reveal_control:t
#+OPTIONS: reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800 reveal_slide_number:c/t
#+OPTIONS: toc:0
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: cube
#+REVEAL_THEME: moon
#+REVEAL_HLEVEL: 2
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="Факты про Datomic.">
#+REVEAL_POSTAMBLE: <p> Created by Alexander Petrov (a.k.a Lysenko). </p>
#+REVEAL_PLUGINS: (markdown notes)
#+REVEAL_EXTRA_CSS: ./local.css

* /Факты/ про *Datomic*

Presentation For [[https://www.meetup.com/Moscow-Clojure-Script-Meetup/events/236838714/][Moscow Clojure/ClojureScript Meetup]]

by [[https://twitter.com/alexpetrov_rb][@alexpetrov_rb]]

25 February 2017

** /Факты/ про *Datomic*

#+ATTR_REVEAL: :frag roll-in
*Факт №1*

#+ATTR_REVEAL: :frag roll-in
*Datomic* про /Факты/

#+ATTR_REVEAL: :frag roll-in
"И это есть /Факт/, Мусьё Дюк!"

#+ATTR_REVEAL: :frag roll-in
(c) Господин Смирнов. "/Неуловимые Мстители. Корона Российской Империи/"

* About me

* Modeling

#+ATTR_REVEAL: :frag roll-in
  Что если моделировать /мир/ как набор /ситуаций/?

#+ATTR_REVEAL: :frag roll-in
  /Ситуация/ - это набор /фактов/ согласованных друг с другом в конкретный /момент времени/.

#+ATTR_REVEAL: :frag roll-in
  В рамках моделируемой части /мира/ нас не будет интересовать ничего за пределами /ситуаций/.

#+ATTR_REVEAL: :frag roll-in
  Мы сможем проигрывать /мир/ функциональным образом проходя через все /ситуации/ хвостовой рекурсией.

Из видео: [[https://www.youtube.com/watch?v=fhOHn9TClXY&feature=youtu.be&t=19m23s][Joe Armstrong Interviews Alan Kay]]

#+BEGIN_NOTES
Set of states in the world, that are consistent with each other at a particular time
#+END_NOTES

** History

The /Idea/ of simulating /Time/ along With /Process/ and /States/ appeared in the paper:

#+ATTR_REVEAL: :frag roll-in
    *1963* /Jonh McCarthy/ [[http://www.dtic.mil/dtic/tr/fulltext/u2/785031.pdf][Situations, Actions and Causal Laws]]

#+ATTR_REVEAL: :frag roll-in
    *2012* /Rich Hickey/ implemented the idea in [[http://www.datomic.com/][Datomic]] database

#+ATTR_REVEAL: :frag roll-in
    *2012 November* /Stuart Halloway/ implemented [[https://github.com/Datomic/simulant/wiki][Simulant]] library to [[https://www.infoq.com/presentations/Simulation-Testing][simulation test]] *Datomic* based systems

#+BEGIN_NOTES
Datomic реализует хранение ситуаций в виде транзакций, а Simulant проигрывает эти ситуации имитируя время с разной скоростью.
Это именно то о чём писал Джон МакКарти.
Всё это делается, чтобы иметь рандомизированные повторяемые black box тесты системы.
#+END_NOTES

** Example

** Immutability

#+BEGIN_NOTES
Здесь нужно рассказать, что такая модель данных делает данные иммутабельными как при работе с данными на бумаге
#+END_NOTES

* /Simple/ Architecture

#+BEGIN_NOTES
А иммутабельность позволяет радикально упростить архитекутру работы с данными
Здесь нужно нарисовать архитекуру Datomic с помощью псевдо графики
#+END_NOTES

* Declarative Logical Query Language /Datalog/

#+BEGIN_NOTES
1977 году создали подходящий язык для построения запросов к datom-ам - Datalog
#+END_NOTES

* Super Powers

#+BEGIN_NOTES
Здесь нужно рассказать про выполнение аналитических запросов относительно консистентного значения всей БД в любой момент времени
и возможность строить спекулятивные запросы
#+END_NOTES

* *Datalog* is /orthogonal/ to *facts* model

Datalog применим для обработки любых структурированных данных.
Но Datomic использует Datalog для обработки Datom-ов.

#+BEGIN_NOTES
В конце сказать, что если не нужна история а нужен Datalog для удобных декларативных запросов к данным, то можно воспользоваться OpenSource-ным DataScript
Это могут быть статически генерируемые сайты, или хранение состояния SPA-приложения.
#+END_NOTES

* /Incidental complexity/ sources

#+ATTR_REVEAL: :frag (appear)
   * Сохранение данных
   * Инвалидация кеша
   * ETL из OLTP в OLAP
   * Интеграция
   * Толстый (Stateful) клиент


** /Desease/ -> *Datomic* /Treatment/

#+ATTR_REVEAL: :frag roll-in
| Impedance Mismatch              | -> [[http://docs.datomic.com/pull.html][Pull API]]              |
| [[https://martinfowler.com/bliki/TwoHardThings.html][Cache Invalidation]]              | -> [[http://docs.datomic.com/architecture.html][Immutability]]          |
| /ETL/ from /OLTP/ to /OLAP/     | -> [[http://docs.datomic.com/clojure/][as-of, since, history]] |
| Integration ( [[https://martinfowler.com/articles/microservices.html]["Microservices"]] ) | -> [[http://docs.datomic.com/project-setup.html][Client]], [[http://docs.datomic.com/rest.html][REST]], [[https://github.com/cognitect-labs/vase][Vase]]    |
| /SPA/ Client /State Management/ | -> [[http://docs.datomic.com/rest.html][REST SSE]], [[https://github.com/tonsky/datascript][DataScript]]  |
| [[https://www.infoq.com/presentations/Simulation-Testing][Simulation Testing]]              | -> [[https://github.com/Datomic/simulant][Simulant]]              |

#+ATTR_REVEAL: :frag roll-in
/Datomic/ [[http://docs.datomic.com/rest.html][REST API]] works but considered legacy

#+BEGIN_NOTES
- Сохранение данных
Datomic убирает impedance mismatch
- ETL для обеспечения аналитической обработки
Datomic избаляет от необходимости вообще иметь ETL, потому что оба типа запросов делаются к одним и тем же данным
- Толстый (Stateful) клиент
Лучше вообще избегать, но если не удаётся, то и тут Datomic спасает. Можно стейт складывать в локальную In Memory database DataScript,
а данные для него получать с помощью слушания лога всех изменений через REST API Server Side Events
- Интеграция
Datomic REST API интеграция как с белым ящиком, в том числе реактивная
Vase позволяет строить RESTful API полностью декларативно для данных в Datomic Интеграция как с "чёрным" ящиком
https://github.com/cognitect-labs/vase
https://github.com/cognitect-labs/vase/blob/master/docs/your_first_api.md
#+END_NOTES

* Why is it worth doing

#+BEGIN_NOTES
На закуску оставить детали реализации и почему это сегодня можно использовать в продакшне не смотря на кажущуюся "Дороговизну" хранения горячего набора данных в памяти.
Можно привести примерные цифры Capacity Planning для разных кусков БД.
И сравнить с использованием проприетарной OLTP БД, ETL платформы и OLAP БД.
Высказать гипотезу, что за счёт многоуровнвого сжатия индексов в Datomic те же данные, возмножно будут занимать меньше места чем в OLAP базе с историческими данными.
#+END_NOTES

* Datomic for non Clojure

* Learning Datomic

* Acknowledgments

* Questions and Additions
